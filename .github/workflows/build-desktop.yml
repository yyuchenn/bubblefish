name: Build Desktop Applications

on:
  push:
    branches:
      - main
      - 'preview_*'
  pull_request:
    branches:
      - main
  workflow_dispatch:
    inputs:
      build_type:
        description: 'Build type'
        required: true
        default: 'all'
        type: choice
        options:
          - all
          - windows-only
          - macos-only
      include_plugins:
        description: 'Include plugins in build'
        required: true
        default: 'both'
        type: choice
        options:
          - both
          - with-plugins
          - without-plugins
  release:
    types: [created]

permissions:
  contents: write
  packages: write

env:
  NODE_VERSION: '20'
  PYTHON_VERSION: '3.11'
  RUST_VERSION: 'stable'

jobs:
  build-windows:
    name: Build for Windows
    runs-on: windows-latest
    if: github.event_name != 'workflow_dispatch' || github.event.inputs.build_type == 'all' || github.event.inputs.build_type == 'windows-only'
    
    env:
      PYTHONIOENCODING: utf-8
      PYTHONUTF8: 1
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: ${{ env.PYTHON_VERSION }}

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}

      - name: Setup Rust
        uses: dtolnay/rust-toolchain@stable
        with:
          toolchain: ${{ env.RUST_VERSION }}
          targets: wasm32-unknown-unknown

      - name: Install Rust nightly
        uses: dtolnay/rust-toolchain@nightly
        with:
          components: rust-src
          targets: wasm32-unknown-unknown

      - name: Cache Rust dependencies
        uses: actions/cache@v4
        with:
          path: |
            ~/.cargo/bin/
            ~/.cargo/registry/index/
            ~/.cargo/registry/cache/
            ~/.cargo/git/db/
            target/
          key: ${{ runner.os }}-cargo-${{ hashFiles('**/Cargo.lock') }}
          restore-keys: |
            ${{ runner.os }}-cargo-

      - name: Cache Node modules
        uses: actions/cache@v4
        with:
          path: |
            frontend/node_modules
            ~/.cache/yarn
          key: ${{ runner.os }}-node-${{ hashFiles('frontend/yarn.lock') }}
          restore-keys: |
            ${{ runner.os }}-node-

      - name: Install wasm-pack
        shell: pwsh
        run: |
          # Check if wasm-pack is already installed and working
          try {
            $version = wasm-pack --version 2>&1
            Write-Host "wasm-pack is already installed: $version"
          } catch {
            Write-Host "Installing wasm-pack..."
            cargo install wasm-pack
          }

      - name: Install Tauri CLI
        shell: pwsh
        run: |
          # Check if cargo-tauri is installed and working
          try {
            $version = cargo tauri --version 2>&1
            if ($LASTEXITCODE -eq 0) {
              Write-Host "Tauri CLI is already installed: $version"
            } else {
              Write-Host "Installing Tauri CLI..."
              cargo install tauri-cli --force
            }
          } catch {
            Write-Host "Installing Tauri CLI..."
            cargo install tauri-cli --force
          }

      - name: Install frontend dependencies
        run: |
          cd frontend
          yarn install

      - name: Build desktop without plugins
        if: github.event_name != 'workflow_dispatch' || github.event.inputs.include_plugins == 'both' || github.event.inputs.include_plugins == 'without-plugins'
        run: python build.py desktop-build
      
      - name: Sign lite version builds
        if: github.event_name == 'release' && (github.event_name != 'workflow_dispatch' || github.event.inputs.include_plugins == 'both' || github.event.inputs.include_plugins == 'without-plugins')
        env:
          TAURI_SIGNING_PRIVATE_KEY: ${{ secrets.TAURI_SIGNING_PRIVATE_KEY }}
          TAURI_SIGNING_PRIVATE_KEY_PASSWORD: ${{ secrets.TAURI_SIGNING_PRIVATE_KEY_PASSWORD || '' }}
        shell: pwsh
        run: |
          # Sign the lite version builds
          $files = @()
          $files += Get-ChildItem -Path "target\release\bundle\msi" -Filter "*.msi" -ErrorAction SilentlyContinue
          $files += Get-ChildItem -Path "target\release\bundle\nsis" -Filter "*.exe" -ErrorAction SilentlyContinue
          
          foreach ($file in $files) {
            if ($file) {
              Write-Host "Signing with Tauri: $($file.FullName)"
              # Write private key to temp file
              $keyPath = New-TemporaryFile
              $env:TAURI_SIGNING_PRIVATE_KEY | Out-File -FilePath $keyPath -Encoding UTF8 -NoNewline
              
              if ([string]::IsNullOrEmpty($env:TAURI_SIGNING_PRIVATE_KEY_PASSWORD)) {
                cargo tauri signer sign --private-key-path "$keyPath" "$($file.FullName)"
              } else {
                cargo tauri signer sign --private-key-path "$keyPath" --password "$env:TAURI_SIGNING_PRIVATE_KEY_PASSWORD" "$($file.FullName)"
              }
              
              Remove-Item $keyPath -Force
            }
          }
      
      - name: Save standard build artifacts
        if: (github.event_name != 'workflow_dispatch' || github.event.inputs.include_plugins == 'both') && (github.event_name != 'workflow_dispatch' || github.event.inputs.include_plugins != 'with-plugins')
        shell: pwsh
        run: |
          # Create backup directory for standard builds
          New-Item -ItemType Directory -Force -Path "target\release\bundle\standard"
          
          # Copy standard builds and signatures to backup location
          if (Test-Path "target\release\bundle\msi\*.msi") {
            Copy-Item "target\release\bundle\msi\*.msi" "target\release\bundle\standard\" -Force
            Copy-Item "target\release\bundle\msi\*.msi.sig" "target\release\bundle\standard\" -Force -ErrorAction SilentlyContinue
            Write-Host "Saved standard MSI files and signatures"
          }
          if (Test-Path "target\release\bundle\nsis\*.exe") {
            Copy-Item "target\release\bundle\nsis\*.exe" "target\release\bundle\standard\" -Force
            Copy-Item "target\release\bundle\nsis\*.exe.sig" "target\release\bundle\standard\" -Force -ErrorAction SilentlyContinue
            Write-Host "Saved standard EXE files and signatures"
          }
      
      - name: Build desktop with native plugins
        if: github.event_name != 'workflow_dispatch' || github.event.inputs.include_plugins == 'both' || github.event.inputs.include_plugins == 'with-plugins'
        run: python build.py desktop-build-all

      - name: Sign bundled version builds
        if: github.event_name == 'release' && (github.event_name != 'workflow_dispatch' || github.event.inputs.include_plugins == 'both' || github.event.inputs.include_plugins == 'with-plugins')
        env:
          TAURI_SIGNING_PRIVATE_KEY: ${{ secrets.TAURI_SIGNING_PRIVATE_KEY }}
          TAURI_SIGNING_PRIVATE_KEY_PASSWORD: ${{ secrets.TAURI_SIGNING_PRIVATE_KEY_PASSWORD || '' }}
        shell: pwsh
        run: |
          # Sign the bundled version builds (only unsigned files)
          $files = @()
          $files += Get-ChildItem -Path "target\release\bundle\msi" -Filter "*.msi" -ErrorAction SilentlyContinue
          $files += Get-ChildItem -Path "target\release\bundle\nsis" -Filter "*.exe" -ErrorAction SilentlyContinue
          
          foreach ($file in $files) {
            if ($file -and -not (Test-Path "$($file.FullName).sig")) {
              Write-Host "Signing with Tauri: $($file.FullName)"
              # Write private key to temp file
              $keyPath = New-TemporaryFile
              $env:TAURI_SIGNING_PRIVATE_KEY | Out-File -FilePath $keyPath -Encoding UTF8 -NoNewline
              
              if ([string]::IsNullOrEmpty($env:TAURI_SIGNING_PRIVATE_KEY_PASSWORD)) {
                cargo tauri signer sign --private-key-path "$keyPath" "$($file.FullName)"
              } else {
                cargo tauri signer sign --private-key-path "$keyPath" --password "$env:TAURI_SIGNING_PRIVATE_KEY_PASSWORD" "$($file.FullName)"
              }
              
              Remove-Item $keyPath -Force
            }
          }

      - name: Sign Windows Executables
        if: env.WINDOWS_CERTIFICATE != '' && env.WINDOWS_CERTIFICATE != null
        env:
          WINDOWS_CERTIFICATE: ${{ secrets.WINDOWS_CERTIFICATE }}
          WINDOWS_CERTIFICATE_PASSWORD: ${{ secrets.WINDOWS_CERTIFICATE_PASSWORD }}
        shell: pwsh
        run: |
          Write-Host "Starting code signing process..."
          
          # Find signtool.exe
          $signtool = Get-ChildItem -Path "C:\Program Files (x86)\Windows Kits\10\bin" -Recurse -Filter "signtool.exe" -ErrorAction SilentlyContinue | 
                      Where-Object { $_.FullName -like "*x64*" } | 
                      Select-Object -First 1
          
          if (-not $signtool) {
            Write-Host "signtool.exe not found, trying alternative locations..."
            $signtool = Get-ChildItem -Path "C:\Program Files\Windows Kits\10\bin" -Recurse -Filter "signtool.exe" -ErrorAction SilentlyContinue | 
                        Where-Object { $_.FullName -like "*x64*" } | 
                        Select-Object -First 1
          }
          
          if (-not $signtool) {
            Write-Host "Error: signtool.exe not found. Windows SDK might not be installed."
            exit 1
          }
          
          $signtoolPath = $signtool.FullName
          Write-Host "Found signtool at: $signtoolPath"
          
          # Decode certificate from base64
          try {
            $certBytes = [System.Convert]::FromBase64String($env:WINDOWS_CERTIFICATE)
            $certPath = "$env:TEMP\code-signing-cert.pfx"
            [System.IO.File]::WriteAllBytes($certPath, $certBytes)
            Write-Host "Certificate decoded successfully"
          } catch {
            Write-Host "Error decoding certificate: $_"
            exit 1
          }
          
          # Find all exe and msi files to sign
          $filesToSign = @()
          $filesToSign += Get-ChildItem -Path "target\release\bundle\msi" -Filter "*.msi" -ErrorAction SilentlyContinue
          $filesToSign += Get-ChildItem -Path "target\release\bundle\nsis" -Filter "*.exe" -ErrorAction SilentlyContinue
          
          if ($filesToSign.Count -eq 0) {
            Write-Host "Warning: No files found to sign"
          } else {
            foreach ($file in $filesToSign) {
              Write-Host "Signing: $($file.FullName)"
              & "$signtoolPath" sign /f "$certPath" /p "$env:WINDOWS_CERTIFICATE_PASSWORD" /t http://timestamp.digicert.com /fd sha256 "$($file.FullName)"
              if ($LASTEXITCODE -ne 0) {
                Write-Host "Warning: Failed to sign $($file.Name)"
              } else {
                Write-Host "Successfully signed: $($file.Name)"
              }
            }
          }
          
          # Clean up certificate file
          Remove-Item $certPath -Force
          Write-Host "Code signing completed"

      - name: Organize artifacts for both versions
        if: github.event_name != 'workflow_dispatch' || github.event.inputs.include_plugins == 'both'
        shell: pwsh
        run: |
          # Restore core builds from backup and rename them
          if (Test-Path "target\release\bundle\standard") {
            # Rename core (no plugins) builds
            Get-ChildItem -Path "target\release\bundle\standard" -Filter "*.msi" | ForEach-Object {
              $newName = $_.Name -replace '\.msi$', '-core.msi'
              Copy-Item $_.FullName "target\release\bundle\msi\$newName" -Force
              Write-Host "Created core version: $newName"
            }
            
            Get-ChildItem -Path "target\release\bundle\standard" -Filter "*.msi.sig" | ForEach-Object {
              $newName = $_.Name -replace '\.msi\.sig$', '-core.msi.sig'
              Copy-Item $_.FullName "target\release\bundle\msi\$newName" -Force
              Write-Host "Created core signature: $newName"
            }
            
            Get-ChildItem -Path "target\release\bundle\standard" -Filter "*.exe" | ForEach-Object {
              $newName = $_.Name -replace '\.exe$', '-core.exe'
              Copy-Item $_.FullName "target\release\bundle\nsis\$newName" -Force
              Write-Host "Created core version: $newName"
            }
            
            Get-ChildItem -Path "target\release\bundle\standard" -Filter "*.exe.sig" | ForEach-Object {
              $newName = $_.Name -replace '\.exe\.sig$', '-core.exe.sig'
              Copy-Item $_.FullName "target\release\bundle\nsis\$newName" -Force
              Write-Host "Created core signature: $newName"
            }
            
            Write-Host "Core builds (without plugins) have been labeled with -core suffix"
            Write-Host "Standard builds (with plugins) keep the original name"
            Remove-Item -Path "target\release\bundle\standard" -Recurse -Force
          }
      
      - name: Upload Windows artifacts
        uses: actions/upload-artifact@v4
        with:
          name: windows-build
          path: |
            target/release/bundle/
          retention-days: 7

      - name: Upload to Release (if release)
        if: github.event_name == 'release'
        uses: softprops/action-gh-release@v2
        with:
          files: |
            target/release/bundle/msi/*.msi
            target/release/bundle/msi/*.msi.sig
            target/release/bundle/nsis/*.exe
            target/release/bundle/nsis/*.exe.sig
          fail_on_unmatched_files: false
          token: ${{ secrets.GITHUB_TOKEN }}

  build-macos:
    name: Build for macOS
    runs-on: macos-latest
    if: github.event_name != 'workflow_dispatch' || github.event.inputs.build_type == 'all' || github.event.inputs.build_type == 'macos-only'
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: ${{ env.PYTHON_VERSION }}

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}

      - name: Setup Rust
        uses: dtolnay/rust-toolchain@stable
        with:
          toolchain: ${{ env.RUST_VERSION }}
          targets: wasm32-unknown-unknown

      - name: Install Rust nightly
        uses: dtolnay/rust-toolchain@nightly
        with:
          components: rust-src
          targets: wasm32-unknown-unknown

      - name: Cache Rust dependencies
        uses: actions/cache@v4
        with:
          path: |
            ~/.cargo/bin/
            ~/.cargo/registry/index/
            ~/.cargo/registry/cache/
            ~/.cargo/git/db/
            target/
          key: ${{ runner.os }}-cargo-${{ hashFiles('**/Cargo.lock') }}
          restore-keys: |
            ${{ runner.os }}-cargo-

      - name: Cache Node modules
        uses: actions/cache@v4
        with:
          path: |
            frontend/node_modules
            ~/.cache/yarn
          key: ${{ runner.os }}-node-${{ hashFiles('frontend/yarn.lock') }}
          restore-keys: |
            ${{ runner.os }}-node-

      - name: Install wasm-pack
        run: |
          # Check if wasm-pack is already installed
          if command -v wasm-pack &> /dev/null; then
            echo "wasm-pack is already installed: $(wasm-pack --version)"
          else
            echo "Installing wasm-pack..."
            curl https://rustwasm.github.io/wasm-pack/installer/init.sh -sSf | sh
          fi

      - name: Install Tauri CLI
        run: |
          # Check if cargo-tauri is installed and working
          if cargo tauri --version &> /dev/null; then
            echo "Tauri CLI is already installed: $(cargo tauri --version)"
          else
            echo "Installing Tauri CLI..."
            cargo install tauri-cli --force
          fi

      - name: Install frontend dependencies
        run: |
          cd frontend
          yarn install

      - name: Build desktop without plugins
        if: github.event_name != 'workflow_dispatch' || github.event.inputs.include_plugins == 'both' || github.event.inputs.include_plugins == 'without-plugins'
        run: python3 build.py desktop-build
      
      - name: Sign lite version builds
        if: github.event_name == 'release' && (github.event_name != 'workflow_dispatch' || github.event.inputs.include_plugins == 'both' || github.event.inputs.include_plugins == 'without-plugins')
        env:
          TAURI_SIGNING_PRIVATE_KEY: ${{ secrets.TAURI_SIGNING_PRIVATE_KEY }}
          TAURI_SIGNING_PRIVATE_KEY_PASSWORD: ${{ secrets.TAURI_SIGNING_PRIVATE_KEY_PASSWORD || '' }}
        run: |
          # Sign the lite version builds
          for file in target/release/bundle/dmg/*.dmg; do
            if [ -f "$file" ]; then
              echo "Signing with Tauri: $file"
              # Write private key to temp file
              KEY_PATH=$(mktemp)
              echo "$TAURI_SIGNING_PRIVATE_KEY" > "$KEY_PATH"
              
              if [ -z "$TAURI_SIGNING_PRIVATE_KEY_PASSWORD" ]; then
                cargo tauri signer sign --private-key-path "$KEY_PATH" "$file"
              else
                cargo tauri signer sign --private-key-path "$KEY_PATH" --password "$TAURI_SIGNING_PRIVATE_KEY_PASSWORD" "$file"
              fi
              
              rm -f "$KEY_PATH"
            fi
          done
      
      - name: Save standard build artifacts
        if: (github.event_name != 'workflow_dispatch' || github.event.inputs.include_plugins == 'both') && (github.event_name != 'workflow_dispatch' || github.event.inputs.include_plugins != 'with-plugins')
        run: |
          # Create backup directory for standard builds
          mkdir -p target/release/bundle/standard
          
          # Copy standard builds and signatures to backup location
          if ls target/release/bundle/dmg/*.dmg 2>/dev/null; then
            cp target/release/bundle/dmg/*.dmg target/release/bundle/standard/
            cp target/release/bundle/dmg/*.dmg.sig target/release/bundle/standard/ 2>/dev/null || true
            echo "Saved standard DMG files and signatures"
          fi
          if ls target/release/bundle/macos/*.app 2>/dev/null; then
            cp -r target/release/bundle/macos/*.app target/release/bundle/standard/
            echo "Saved standard APP bundles"
          fi
      
      - name: Build desktop with native plugins
        if: github.event_name != 'workflow_dispatch' || github.event.inputs.include_plugins == 'both' || github.event.inputs.include_plugins == 'with-plugins'
        run: python3 build.py desktop-build-all

      - name: Sign bundled version builds
        if: github.event_name == 'release' && (github.event_name != 'workflow_dispatch' || github.event.inputs.include_plugins == 'both' || github.event.inputs.include_plugins == 'with-plugins')
        env:
          TAURI_SIGNING_PRIVATE_KEY: ${{ secrets.TAURI_SIGNING_PRIVATE_KEY }}
          TAURI_SIGNING_PRIVATE_KEY_PASSWORD: ${{ secrets.TAURI_SIGNING_PRIVATE_KEY_PASSWORD || '' }}
        run: |
          # Sign the bundled version builds (only unsigned files)
          for file in target/release/bundle/dmg/*.dmg; do
            if [ -f "$file" ] && [ ! -f "$file.sig" ]; then
              echo "Signing with Tauri: $file"
              # Write private key to temp file
              KEY_PATH=$(mktemp)
              echo "$TAURI_SIGNING_PRIVATE_KEY" > "$KEY_PATH"
              
              if [ -z "$TAURI_SIGNING_PRIVATE_KEY_PASSWORD" ]; then
                cargo tauri signer sign --private-key-path "$KEY_PATH" "$file"
              else
                cargo tauri signer sign --private-key-path "$KEY_PATH" --password "$TAURI_SIGNING_PRIVATE_KEY_PASSWORD" "$file"
              fi
              
              rm -f "$KEY_PATH"
            fi
          done

      - name: Package macOS app for release
        if: github.event_name == 'release'
        run: |
          # Find and compress .app bundles for release
          for app in target/release/bundle/macos/*.app; do
            if [ -d "$app" ]; then
              app_name=$(basename "$app")
              tar -czf "target/release/bundle/macos/${app_name}.tar.gz" -C "target/release/bundle/macos" "$app_name"
              echo "Created ${app_name}.tar.gz"
              
              # Sign the tar.gz file if this is a release
              if [ "${{ github.event_name }}" = "release" ] && [ -n "${{ secrets.TAURI_SIGNING_PRIVATE_KEY }}" ]; then
                KEY_PATH=$(mktemp)
                echo "${{ secrets.TAURI_SIGNING_PRIVATE_KEY }}" > "$KEY_PATH"
                
                if [ -z "${{ secrets.TAURI_SIGNING_PRIVATE_KEY_PASSWORD }}" ]; then
                  cargo tauri signer sign --private-key-path "$KEY_PATH" "target/release/bundle/macos/${app_name}.tar.gz"
                else
                  cargo tauri signer sign --private-key-path "$KEY_PATH" --password "${{ secrets.TAURI_SIGNING_PRIVATE_KEY_PASSWORD }}" "target/release/bundle/macos/${app_name}.tar.gz"
                fi
                
                rm -f "$KEY_PATH"
              fi
            fi
          done

      - name: Organize artifacts for both versions
        if: github.event_name != 'workflow_dispatch' || github.event.inputs.include_plugins == 'both'
        run: |
          # Restore core builds from backup and rename them
          if [ -d "target/release/bundle/standard" ]; then
            # Rename core (no plugins) builds
            for dmg in target/release/bundle/standard/*.dmg; do
              if [ -f "$dmg" ]; then
                filename=$(basename "$dmg")
                newname="${filename%.dmg}-core.dmg"
                cp "$dmg" "target/release/bundle/dmg/$newname"
                echo "Created core version: $newname"
              fi
            done
            
            for sig in target/release/bundle/standard/*.dmg.sig; do
              if [ -f "$sig" ]; then
                filename=$(basename "$sig")
                newname="${filename%.dmg.sig}-core.dmg.sig"
                cp "$sig" "target/release/bundle/dmg/$newname"
                echo "Created core signature: $newname"
              fi
            done
            
            for app in target/release/bundle/standard/*.app; do
              if [ -d "$app" ]; then
                dirname=$(basename "$app")
                newname="${dirname%.app}-core.app"
                cp -r "$app" "target/release/bundle/macos/$newname"
                echo "Created core version: $newname"
                
                # Create tar.gz for core app
                tar -czf "target/release/bundle/macos/${newname}.tar.gz" -C "target/release/bundle/macos" "$newname"
                
                # Sign the core tar.gz file if this is a release
                if [ "${{ github.event_name }}" = "release" ] && [ -n "${{ secrets.TAURI_SIGNING_PRIVATE_KEY }}" ]; then
                  KEY_PATH=$(mktemp)
                  echo "${{ secrets.TAURI_SIGNING_PRIVATE_KEY }}" > "$KEY_PATH"
                  
                  if [ -z "${{ secrets.TAURI_SIGNING_PRIVATE_KEY_PASSWORD }}" ]; then
                    cargo tauri signer sign --private-key-path "$KEY_PATH" "target/release/bundle/macos/${newname}.tar.gz"
                  else
                    cargo tauri signer sign --private-key-path "$KEY_PATH" --password "${{ secrets.TAURI_SIGNING_PRIVATE_KEY_PASSWORD }}" "target/release/bundle/macos/${newname}.tar.gz"
                  fi
                  
                  rm -f "$KEY_PATH"
                fi
              fi
            done
            
            echo "Core builds (without plugins) have been labeled with -core suffix"
            echo "Standard builds (with plugins) keep the original name"
            rm -rf target/release/bundle/standard
          fi
      
      - name: Upload macOS artifacts
        uses: actions/upload-artifact@v4
        with:
          name: macos-build
          path: |
            target/release/bundle/macos/*.app
            target/release/bundle/macos/*.app.tar.gz
            target/release/bundle/macos/*.app.tar.gz.sig
            target/release/bundle/dmg/*.dmg
            target/release/bundle/dmg/*.dmg.sig
          retention-days: 7

      - name: Upload to Release (if release)
        if: github.event_name == 'release'
        uses: softprops/action-gh-release@v2
        with:
          files: |
            target/release/bundle/dmg/*.dmg
            target/release/bundle/dmg/*.dmg.sig
            target/release/bundle/macos/*.app.tar.gz
            target/release/bundle/macos/*.app.tar.gz.sig
          fail_on_unmatched_files: false
          token: ${{ secrets.GITHUB_TOKEN }}

  create-release-summary:
    name: Create Release Summary
    runs-on: ubuntu-latest
    needs: [build-windows, build-macos]
    if: always() && (github.event_name == 'release' || github.event_name == 'workflow_dispatch' || github.event_name == 'push')
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Download all artifacts
        uses: actions/download-artifact@v4
        with:
          path: artifacts/

      - name: Generate checksums and summary
        run: |
          # Create summary file
          SUMMARY_FILE="build-summary.md"
          
          echo "# Build Summary" > $SUMMARY_FILE
          echo "" >> $SUMMARY_FILE
          echo "**Build Date:** $(date -u +"%Y-%m-%d %H:%M:%S UTC")" >> $SUMMARY_FILE
          echo "**Commit:** ${{ github.sha }}" >> $SUMMARY_FILE
          echo "**Branch:** ${{ github.ref_name }}" >> $SUMMARY_FILE
          echo "" >> $SUMMARY_FILE
          
          echo "## Build Variants" >> $SUMMARY_FILE
          echo "" >> $SUMMARY_FILE
          echo "- **Standard Version** (Bubblefish.*): Full-featured version with native plugins included" >> $SUMMARY_FILE
          echo "- **Core Version** (Bubblefish-core.*): Lightweight version without plugins" >> $SUMMARY_FILE
          echo "" >> $SUMMARY_FILE
          
          echo "## Build Artifacts with MD5 Checksums" >> $SUMMARY_FILE
          echo "" >> $SUMMARY_FILE
          
          # Windows artifacts
          echo "### Windows" >> $SUMMARY_FILE
          echo "" >> $SUMMARY_FILE
          echo "| File | Size | MD5 |" >> $SUMMARY_FILE
          echo "|------|------|-----|" >> $SUMMARY_FILE
          
          find artifacts/windows-build -type f \( -name "*.exe" -o -name "*.msi" \) 2>/dev/null | while read f; do
            if [ -f "$f" ]; then
              filename=$(basename "$f")
              filesize=$(du -h "$f" | cut -f1)
              md5sum=$(md5sum "$f" | cut -d' ' -f1)
              echo "| $filename | $filesize | \`$md5sum\` |" >> $SUMMARY_FILE
            fi
          done || echo "| No Windows artifacts found | - | - |" >> $SUMMARY_FILE
          
          echo "" >> $SUMMARY_FILE
          
          # macOS artifacts
          echo "### macOS" >> $SUMMARY_FILE
          echo "" >> $SUMMARY_FILE
          echo "| File | Size | MD5 |" >> $SUMMARY_FILE
          echo "|------|------|-----|" >> $SUMMARY_FILE
          
          find artifacts/macos-build -type f \( -name "*.dmg" -o -name "*.app.tar.gz" -o -name "*.app" \) 2>/dev/null | while read f; do
            if [ -f "$f" ]; then
              filename=$(basename "$f")
              filesize=$(du -h "$f" | cut -f1)
              md5sum=$(md5sum "$f" | cut -d' ' -f1)
              echo "| $filename | $filesize | \`$md5sum\` |" >> $SUMMARY_FILE
            fi
          done || echo "| No macOS artifacts found | - | - |" >> $SUMMARY_FILE
          
          echo "" >> $SUMMARY_FILE
          
          # Generate checksums file
          echo "## Checksums File" >> $SUMMARY_FILE
          echo "" >> $SUMMARY_FILE
          echo "A \`checksums.md5\` file has been generated with all MD5 hashes." >> $SUMMARY_FILE
          
          # Create MD5 checksums file
          CHECKSUM_FILE="checksums.md5"
          echo "# MD5 Checksums for Bubblefish Build" > $CHECKSUM_FILE
          echo "# Generated: $(date -u +"%Y-%m-%d %H:%M:%S UTC")" >> $CHECKSUM_FILE
          echo "" >> $CHECKSUM_FILE
          
          find artifacts -type f \( -name "*.exe" -o -name "*.msi" -o -name "*.dmg" -o -name "*.app.tar.gz" \) 2>/dev/null | while read f; do
            if [ -f "$f" ]; then
              md5sum "$f" | sed "s|artifacts/[^/]*/||" >> $CHECKSUM_FILE
            fi
          done
          
          # Display summary in job output
          cat $SUMMARY_FILE
          
          # Also create GitHub step summary
          cat $SUMMARY_FILE >> $GITHUB_STEP_SUMMARY

      - name: Upload summary as artifact
        uses: actions/upload-artifact@v4
        with:
          name: build-summary
          path: |
            build-summary.md
            checksums.md5
          retention-days: 30

      - name: Add summary to release (if release)
        if: github.event_name == 'release'
        uses: softprops/action-gh-release@v2
        with:
          files: |
            build-summary.md
            checksums.md5
          fail_on_unmatched_files: false
          token: ${{ secrets.GITHUB_TOKEN }}

  trigger-update-manifests:
    name: Trigger Update Manifests
    runs-on: ubuntu-latest
    needs: [build-windows, build-macos]
    if: github.event_name == 'release'
    
    steps:
      - name: Trigger update manifests workflow
        uses: actions/github-script@v7
        with:
          script: |
            await github.rest.actions.createWorkflowDispatch({
              owner: context.repo.owner,
              repo: context.repo.repo,
              workflow_id: 'update-manifests.yml',
              ref: 'main',
              inputs: {
                version: '${{ github.event.release.tag_name }}',
                release_url: '${{ github.event.release.html_url }}'
              }
            })