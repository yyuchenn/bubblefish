name: Build Desktop Applications

on:
  push:
    branches:
      - main
      - 'preview_*'
  pull_request:
    branches:
      - main
  workflow_dispatch:
    inputs:
      build_type:
        description: 'Build type'
        required: true
        default: 'all'
        type: choice
        options:
          - all
          - windows-only
          - macos-only
  release:
    types: [created]

permissions:
  contents: write
  packages: write

env:
  NODE_VERSION: '20'
  PYTHON_VERSION: '3.11'
  RUST_VERSION: 'stable'

jobs:
  build-windows:
    name: Build for Windows
    runs-on: windows-latest
    if: github.event_name != 'workflow_dispatch' || github.event.inputs.build_type == 'all' || github.event.inputs.build_type == 'windows-only'
    
    env:
      PYTHONIOENCODING: utf-8
      PYTHONUTF8: 1
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: ${{ env.PYTHON_VERSION }}

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}

      - name: Setup Rust
        uses: dtolnay/rust-toolchain@stable
        with:
          toolchain: ${{ env.RUST_VERSION }}
          targets: wasm32-unknown-unknown

      - name: Install Rust nightly
        uses: dtolnay/rust-toolchain@nightly
        with:
          components: rust-src
          targets: wasm32-unknown-unknown

      - name: Cache Rust dependencies
        uses: actions/cache@v4
        with:
          path: |
            ~/.cargo/bin/
            ~/.cargo/registry/index/
            ~/.cargo/registry/cache/
            ~/.cargo/git/db/
            target/
          key: ${{ runner.os }}-cargo-${{ hashFiles('**/Cargo.lock') }}
          restore-keys: |
            ${{ runner.os }}-cargo-

      - name: Cache Node modules
        uses: actions/cache@v4
        with:
          path: |
            frontend/node_modules
            ~/.cache/yarn
          key: ${{ runner.os }}-node-${{ hashFiles('frontend/yarn.lock') }}
          restore-keys: |
            ${{ runner.os }}-node-

      - name: Install wasm-pack
        shell: pwsh
        run: |
          # Check if wasm-pack is already installed and working
          try {
            $version = wasm-pack --version 2>&1
            Write-Host "wasm-pack is already installed: $version"
          } catch {
            Write-Host "Installing wasm-pack..."
            cargo install wasm-pack
          }

      - name: Install Tauri CLI
        shell: pwsh
        run: |
          # Check if cargo-tauri is installed and working
          try {
            $version = cargo tauri --version 2>&1
            if ($LASTEXITCODE -eq 0) {
              Write-Host "Tauri CLI is already installed: $version"
            } else {
              Write-Host "Installing Tauri CLI..."
              cargo install tauri-cli --force
            }
          } catch {
            Write-Host "Installing Tauri CLI..."
            cargo install tauri-cli --force
          }

      - name: Install frontend dependencies
        run: |
          cd frontend
          yarn install

      - name: Build desktop
        run: python build.py desktop-build
      
      - name: Sign builds
        if: github.event_name == 'release'
        env:
          TAURI_PRIVATE_KEY: ${{ secrets.TAURI_SIGNING_PRIVATE_KEY }}
          TAURI_KEY_PASSWORD: ${{ secrets.TAURI_SIGNING_PRIVATE_KEY_PASSWORD || '' }}
        shell: pwsh
        run: |
          # Sign the builds
          # cargo tauri signer uses TAURI_PRIVATE_KEY and TAURI_KEY_PASSWORD env vars automatically
          $files = @()
          $files += Get-ChildItem -Path "target\release\bundle\msi" -Filter "*.msi" -ErrorAction SilentlyContinue
          $files += Get-ChildItem -Path "target\release\bundle\nsis" -Filter "*.exe" -ErrorAction SilentlyContinue
          
          foreach ($file in $files) {
            if ($file) {
              Write-Host "Signing with Tauri: $($file.FullName)"
              cargo tauri signer sign "$($file.FullName)"
            }
          }

      - name: Sign Windows Executables
        if: env.WINDOWS_CERTIFICATE != '' && env.WINDOWS_CERTIFICATE != null
        env:
          WINDOWS_CERTIFICATE: ${{ secrets.WINDOWS_CERTIFICATE }}
          WINDOWS_CERTIFICATE_PASSWORD: ${{ secrets.WINDOWS_CERTIFICATE_PASSWORD }}
        shell: pwsh
        run: |
          Write-Host "Starting code signing process..."
          
          # Find signtool.exe
          $signtool = Get-ChildItem -Path "C:\Program Files (x86)\Windows Kits\10\bin" -Recurse -Filter "signtool.exe" -ErrorAction SilentlyContinue | 
                      Where-Object { $_.FullName -like "*x64*" } | 
                      Select-Object -First 1
          
          if (-not $signtool) {
            Write-Host "signtool.exe not found, trying alternative locations..."
            $signtool = Get-ChildItem -Path "C:\Program Files\Windows Kits\10\bin" -Recurse -Filter "signtool.exe" -ErrorAction SilentlyContinue | 
                        Where-Object { $_.FullName -like "*x64*" } | 
                        Select-Object -First 1
          }
          
          if (-not $signtool) {
            Write-Host "Error: signtool.exe not found. Windows SDK might not be installed."
            exit 1
          }
          
          $signtoolPath = $signtool.FullName
          Write-Host "Found signtool at: $signtoolPath"
          
          # Decode certificate from base64
          try {
            $certBytes = [System.Convert]::FromBase64String($env:WINDOWS_CERTIFICATE)
            $certPath = "$env:TEMP\code-signing-cert.pfx"
            [System.IO.File]::WriteAllBytes($certPath, $certBytes)
            Write-Host "Certificate decoded successfully"
          } catch {
            Write-Host "Error decoding certificate: $_"
            exit 1
          }
          
          # Find all exe and msi files to sign
          $filesToSign = @()
          $filesToSign += Get-ChildItem -Path "target\release\bundle\msi" -Filter "*.msi" -ErrorAction SilentlyContinue
          $filesToSign += Get-ChildItem -Path "target\release\bundle\nsis" -Filter "*.exe" -ErrorAction SilentlyContinue
          
          if ($filesToSign.Count -eq 0) {
            Write-Host "Warning: No files found to sign"
          } else {
            foreach ($file in $filesToSign) {
              Write-Host "Signing: $($file.FullName)"
              & "$signtoolPath" sign /f "$certPath" /p "$env:WINDOWS_CERTIFICATE_PASSWORD" /t http://timestamp.digicert.com /fd sha256 "$($file.FullName)"
              if ($LASTEXITCODE -ne 0) {
                Write-Host "Warning: Failed to sign $($file.Name)"
              } else {
                Write-Host "Successfully signed: $($file.Name)"
              }
            }
          }
          
          # Clean up certificate file
          Remove-Item $certPath -Force
          Write-Host "Code signing completed"
      
      - name: Upload Windows artifacts
        uses: actions/upload-artifact@v4
        with:
          name: windows-build
          path: |
            target/release/bundle/
          retention-days: 7

      - name: Upload to Release (if release)
        if: github.event_name == 'release'
        uses: softprops/action-gh-release@v2
        with:
          files: |
            target/release/bundle/msi/*.msi
            target/release/bundle/msi/*.msi.sig
            target/release/bundle/nsis/*.exe
            target/release/bundle/nsis/*.exe.sig
          fail_on_unmatched_files: false
          token: ${{ secrets.GITHUB_TOKEN }}

  build-macos:
    name: Build for macOS
    runs-on: macos-latest
    if: github.event_name != 'workflow_dispatch' || github.event.inputs.build_type == 'all' || github.event.inputs.build_type == 'macos-only'
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: ${{ env.PYTHON_VERSION }}

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}

      - name: Setup Rust
        uses: dtolnay/rust-toolchain@stable
        with:
          toolchain: ${{ env.RUST_VERSION }}
          targets: wasm32-unknown-unknown

      - name: Install Rust nightly
        uses: dtolnay/rust-toolchain@nightly
        with:
          components: rust-src
          targets: wasm32-unknown-unknown

      - name: Cache Rust dependencies
        uses: actions/cache@v4
        with:
          path: |
            ~/.cargo/bin/
            ~/.cargo/registry/index/
            ~/.cargo/registry/cache/
            ~/.cargo/git/db/
            target/
          key: ${{ runner.os }}-cargo-${{ hashFiles('**/Cargo.lock') }}
          restore-keys: |
            ${{ runner.os }}-cargo-

      - name: Cache Node modules
        uses: actions/cache@v4
        with:
          path: |
            frontend/node_modules
            ~/.cache/yarn
          key: ${{ runner.os }}-node-${{ hashFiles('frontend/yarn.lock') }}
          restore-keys: |
            ${{ runner.os }}-node-

      - name: Install wasm-pack
        run: |
          # Check if wasm-pack is already installed
          if command -v wasm-pack &> /dev/null; then
            echo "wasm-pack is already installed: $(wasm-pack --version)"
          else
            echo "Installing wasm-pack..."
            curl https://rustwasm.github.io/wasm-pack/installer/init.sh -sSf | sh
          fi

      - name: Install Tauri CLI
        run: |
          # Check if cargo-tauri is installed and working
          if cargo tauri --version &> /dev/null; then
            echo "Tauri CLI is already installed: $(cargo tauri --version)"
          else
            echo "Installing Tauri CLI..."
            cargo install tauri-cli --force
          fi

      - name: Install frontend dependencies
        run: |
          cd frontend
          yarn install

      - name: Build desktop
        run: python3 build.py desktop-build
      
      - name: Sign builds
        if: github.event_name == 'release'
        env:
          TAURI_PRIVATE_KEY: ${{ secrets.TAURI_SIGNING_PRIVATE_KEY }}
          TAURI_KEY_PASSWORD: ${{ secrets.TAURI_SIGNING_PRIVATE_KEY_PASSWORD || '' }}
        run: |
          # Sign the builds
          # cargo tauri signer uses TAURI_PRIVATE_KEY and TAURI_KEY_PASSWORD env vars automatically
          for file in target/release/bundle/dmg/*.dmg; do
            if [ -f "$file" ]; then
              echo "Signing with Tauri: $file"
              cargo tauri signer sign "$file"
            fi
          done

      - name: Package macOS app for release
        if: github.event_name == 'release'
        env:
          TAURI_PRIVATE_KEY: ${{ secrets.TAURI_SIGNING_PRIVATE_KEY }}
          TAURI_KEY_PASSWORD: ${{ secrets.TAURI_SIGNING_PRIVATE_KEY_PASSWORD || '' }}
        run: |
          # Find and compress .app bundles for release
          for app in target/release/bundle/macos/*.app; do
            if [ -d "$app" ]; then
              app_name=$(basename "$app")
              tar -czf "target/release/bundle/macos/${app_name}.tar.gz" -C "target/release/bundle/macos" "$app_name"
              echo "Created ${app_name}.tar.gz"
              
              # Sign the tar.gz file if private key is available
              if [ -n "$TAURI_PRIVATE_KEY" ]; then
                cargo tauri signer sign "target/release/bundle/macos/${app_name}.tar.gz"
              fi
            fi
          done
      
      - name: Upload macOS artifacts
        uses: actions/upload-artifact@v4
        with:
          name: macos-build
          path: |
            target/release/bundle/macos/*.app
            target/release/bundle/macos/*.app.tar.gz
            target/release/bundle/macos/*.app.tar.gz.sig
            target/release/bundle/dmg/*.dmg
            target/release/bundle/dmg/*.dmg.sig
          retention-days: 7

      - name: Upload to Release (if release)
        if: github.event_name == 'release'
        uses: softprops/action-gh-release@v2
        with:
          files: |
            target/release/bundle/dmg/*.dmg
            target/release/bundle/dmg/*.dmg.sig
            target/release/bundle/macos/*.app.tar.gz
            target/release/bundle/macos/*.app.tar.gz.sig
          fail_on_unmatched_files: false
          token: ${{ secrets.GITHUB_TOKEN }}

  create-release-summary:
    name: Create Release Summary
    runs-on: ubuntu-latest
    needs: [build-windows, build-macos]
    if: always() && (github.event_name == 'release' || github.event_name == 'workflow_dispatch' || github.event_name == 'push')
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Download all artifacts
        uses: actions/download-artifact@v4
        with:
          path: artifacts/

      - name: Generate checksums and summary
        run: |
          # Create summary file
          SUMMARY_FILE="build-summary.md"
          
          echo "# Build Summary" > $SUMMARY_FILE
          echo "" >> $SUMMARY_FILE
          echo "**Build Date:** $(date -u +"%Y-%m-%d %H:%M:%S UTC")" >> $SUMMARY_FILE
          echo "**Commit:** ${{ github.sha }}" >> $SUMMARY_FILE
          echo "**Branch:** ${{ github.ref_name }}" >> $SUMMARY_FILE
          echo "" >> $SUMMARY_FILE
          
          echo "## Build Artifacts with MD5 Checksums" >> $SUMMARY_FILE
          echo "" >> $SUMMARY_FILE
          
          # Windows artifacts
          echo "### Windows" >> $SUMMARY_FILE
          echo "" >> $SUMMARY_FILE
          echo "| File | Size | MD5 |" >> $SUMMARY_FILE
          echo "|------|------|-----|" >> $SUMMARY_FILE
          
          find artifacts/windows-build -type f \( -name "*.exe" -o -name "*.msi" \) 2>/dev/null | while read f; do
            if [ -f "$f" ]; then
              filename=$(basename "$f")
              filesize=$(du -h "$f" | cut -f1)
              md5sum=$(md5sum "$f" | cut -d' ' -f1)
              echo "| $filename | $filesize | \`$md5sum\` |" >> $SUMMARY_FILE
            fi
          done || echo "| No Windows artifacts found | - | - |" >> $SUMMARY_FILE
          
          echo "" >> $SUMMARY_FILE
          
          # macOS artifacts
          echo "### macOS" >> $SUMMARY_FILE
          echo "" >> $SUMMARY_FILE
          echo "| File | Size | MD5 |" >> $SUMMARY_FILE
          echo "|------|------|-----|" >> $SUMMARY_FILE
          
          find artifacts/macos-build -type f \( -name "*.dmg" -o -name "*.app.tar.gz" -o -name "*.app" \) 2>/dev/null | while read f; do
            if [ -f "$f" ]; then
              filename=$(basename "$f")
              filesize=$(du -h "$f" | cut -f1)
              md5sum=$(md5sum "$f" | cut -d' ' -f1)
              echo "| $filename | $filesize | \`$md5sum\` |" >> $SUMMARY_FILE
            fi
          done || echo "| No macOS artifacts found | - | - |" >> $SUMMARY_FILE
          
          echo "" >> $SUMMARY_FILE
          
          # Generate checksums file
          echo "## Checksums File" >> $SUMMARY_FILE
          echo "" >> $SUMMARY_FILE
          echo "A \`checksums.md5\` file has been generated with all MD5 hashes." >> $SUMMARY_FILE
          
          # Create MD5 checksums file
          CHECKSUM_FILE="checksums.md5"
          echo "# MD5 Checksums for Bubblefish Build" > $CHECKSUM_FILE
          echo "# Generated: $(date -u +"%Y-%m-%d %H:%M:%S UTC")" >> $CHECKSUM_FILE
          echo "" >> $CHECKSUM_FILE
          
          find artifacts -type f \( -name "*.exe" -o -name "*.msi" -o -name "*.dmg" -o -name "*.app.tar.gz" \) 2>/dev/null | while read f; do
            if [ -f "$f" ]; then
              md5sum "$f" | sed "s|artifacts/[^/]*/||" >> $CHECKSUM_FILE
            fi
          done
          
          # Display summary in job output
          cat $SUMMARY_FILE
          
          # Also create GitHub step summary
          cat $SUMMARY_FILE >> $GITHUB_STEP_SUMMARY

      - name: Upload summary as artifact
        uses: actions/upload-artifact@v4
        with:
          name: build-summary
          path: |
            build-summary.md
            checksums.md5
          retention-days: 30

      - name: Add summary to release (if release)
        if: github.event_name == 'release'
        uses: softprops/action-gh-release@v2
        with:
          files: |
            build-summary.md
            checksums.md5
          fail_on_unmatched_files: false
          token: ${{ secrets.GITHUB_TOKEN }}

  trigger-update-manifests:
    name: Trigger Update Manifests
    runs-on: ubuntu-latest
    needs: [build-windows, build-macos]
    if: github.event_name == 'release'
    
    steps:
      - name: Trigger update manifests workflow
        uses: actions/github-script@v7
        with:
          script: |
            await github.rest.actions.createWorkflowDispatch({
              owner: context.repo.owner,
              repo: context.repo.repo,
              workflow_id: 'update-manifests.yml',
              ref: 'main',
              inputs: {
                version: '${{ github.event.release.tag_name }}',
                release_url: '${{ github.event.release.html_url }}'
              }
            })